# AI Assistant Context - Hiring Tool

## üéØ Critical Information for AI Assistants

This document provides essential context for AI assistants (Claude, Cursor) working on this codebase.

---

## Authentication System (IMPORTANT!)

### Full-Stack Authentication with TanStack Start

This app uses a **custom auth proxy pattern** that makes TanStack Start a true full-stack framework.

### üî• Key Pattern: Auth Proxy + Server Validation

```typescript
// Auth flow:
Browser ‚Üí /api/auth/* (proxy) ‚Üí Backend ‚Üí Database
              ‚Üì
         Cookies work (same origin!)
              ‚Üì
    Server validates in beforeLoad
              ‚Üì
      Context flows to components
```

### When Working with Auth, Remember:

1. **Never bypass the proxy**

   ```typescript
   // ‚úÖ CORRECT - Uses proxy
   const authClient = createAuthClient({
     basePath: "/api/auth",
   });

   // ‚ùå WRONG - Bypasses proxy, cookies won't work
   const authClient = createAuthClient({
     baseURL: "https://backend.com",
   });
   ```

2. **Use server-side validation**

   ```typescript
   // ‚úÖ CORRECT - Validates on server
   beforeLoad: async () => {
     const session = await getAuthSession();
     return { session, isAuthenticated: !!session };
   }

   // ‚ùå WRONG - Client-only, can be bypassed
   useEffect(() => {
     if (!session) navigate("/login");
   }, []);
   ```

3. **Access session via context**

   ```typescript
   // ‚úÖ CORRECT - Uses server-validated session
   const { session, isAuthenticated } = Route.useRouteContext();

   // ‚ùå AVOID - Client-only, not server-validated
   const { data: session } = authClient.useSession();
   ```

4. **Respect the cache**

   ```typescript
   // ‚úÖ CORRECT - Uses 10-minute cache
   export const Route = createRootRouteWithContext<RouterAppContext>()({
     staleTime: 10 * 60 * 1000,
     beforeLoad: async () => { /* ... */ }
   });

   // ‚ùå WRONG - Disables cache unnecessarily
   staleTime: 0,  // Don't do this!
   ```

### File Locations

```
apps/web/src/
‚îú‚îÄ‚îÄ routes/
‚îÇ   ‚îú‚îÄ‚îÄ __root.tsx                    # üî• Session validation in beforeLoad
‚îÇ   ‚îú‚îÄ‚îÄ _authenticated.tsx            # Protected route layout
‚îÇ   ‚îî‚îÄ‚îÄ api/auth/$.ts                 # üî• Auth proxy (ALL auth requests)
‚îÇ
‚îî‚îÄ‚îÄ lib/auth/
    ‚îú‚îÄ‚îÄ auth-client.ts                # Client-side auth (uses proxy)
    ‚îú‚îÄ‚îÄ auth-server.ts                # Server-side auth instance
    ‚îî‚îÄ‚îÄ functions.ts                  # getAuthSession() server function
```

---

## Data Flow Patterns

### Server ‚Üí Client Data Flow

```typescript
// 1. Server validates (beforeLoad)
beforeLoad: async () => {
  const data = await serverFunction();
  return { data }; // ‚Üê Goes into context
}

// 2. Component accesses (useRouteContext)
function Component() {
  const { data } = Route.useRouteContext(); // ‚Üê Gets from context
  return <div>{data}</div>;
}
```

### Context Hierarchy

```
__root.tsx
  ‚îî‚îÄ returns { session, isAuthenticated }
      ‚îî‚îÄ Available in ALL child routes via Route.useRouteContext()
          ‚îî‚îÄ _authenticated.tsx
              ‚îî‚îÄ Can access parent context
                  ‚îî‚îÄ _authenticated/hiring-processes/index.tsx
                      ‚îî‚îÄ Can access all parent contexts
```

---

## Caching Rules

### Three-Layer Cache System

1. **Backend Cache** (Better Auth): 10 minutes in memory
2. **Route Cache** (TanStack Router): 10 minutes via `staleTime`
3. **Context Cache** (React): Component lifecycle

### When to Invalidate Cache

```typescript
// After mutations that affect auth state
await authClient.signIn.email({ email, password });
// ‚Üí Automatically invalidates session cache

await authClient.signOut();
// ‚Üí Automatically invalidates session cache

// Manual invalidation (rarely needed)
queryClient.invalidateQueries({ queryKey: ['session'] });
```

### Performance Impact

- **Before caching**: ~10 DB queries/minute per user
- **After caching**: ~1 DB query/10 minutes per user
- **Reduction**: ~90% fewer database queries ‚úÖ

---

## Common Patterns to Follow

### Pattern 1: Protected Route

```typescript
// Create under _authenticated/ directory
export const Route = createFileRoute("/_authenticated/my-page")({
  component: MyPage,
  // beforeLoad from parent already validates session
});

function MyPage() {
  const { session } = Route.useRouteContext();
  // Session guaranteed to exist here
  return <div>Hello, {session.user?.name}!</div>;
}
```

### Pattern 2: Conditional UI Based on Auth

```typescript
function Navigation() {
  const { isAuthenticated, session } = Route.useRouteContext();

  return (
    <nav>
      {isAuthenticated ? (
        <UserMenu user={session.user} />
      ) : (
        <Link to="/auth/login">Login</Link>
      )}
    </nav>
  );
}
```

### Pattern 3: Server-Side Redirect

```typescript
beforeLoad: async () => {
  const session = await getAuthSession();

  if (!session) {
    throw redirect({ to: "/auth/login" });
  }

  return { session };
}
```

### Pattern 4: Role-Based Access

```typescript
beforeLoad: async () => {
  const session = await getAuthSession();

  if (session?.user?.role !== "admin") {
    throw redirect({ to: "/" });
  }

  return { session };
}
```

---

## ‚ö†Ô∏è Common Mistakes to Avoid

### ‚ùå Don't Call Backend Directly from Client

```typescript
// ‚ùå WRONG - Bypasses proxy, cookies won't work
await fetch("https://backend.com/api/auth/sign-in", {
  method: "POST",
  body: JSON.stringify({ email, password }),
});

// ‚úÖ CORRECT - Uses proxy
await authClient.signIn.email({ email, password });
```

### ‚ùå Don't Store Session in localStorage

```typescript
// ‚ùå WRONG - Security risk
localStorage.setItem("session", JSON.stringify(session));

// ‚úÖ CORRECT - Sessions in HttpOnly cookies (automatic)
// Nothing to do! Better Auth handles it.
```

### ‚ùå Don't Disable Caching Without Reason

```typescript
// ‚ùå WRONG - Causes unnecessary DB queries
staleTime: 0,

// ‚úÖ CORRECT - Let cache work
staleTime: 10 * 60 * 1000,
```

### ‚ùå Don't Use Client-Side Only Auth Checks

```typescript
// ‚ùå WRONG - Can be bypassed
useEffect(() => {
  if (!session) navigate("/login");
}, []);

// ‚úÖ CORRECT - Server-side validation
beforeLoad: async () => {
  const session = await getAuthSession();
  if (!session) throw redirect({ to: "/login" });
}
```

---

## ü§ñ AI Assistant Instructions

### When Adding New Protected Routes

1. Create file under `_authenticated/` directory
2. Use `Route.useRouteContext()` to access session
3. No need to re-validate (parent already does it)
4. Session is guaranteed to exist in these routes

### When Adding Auth Actions

1. Always use `authClient` from `@/lib/auth/auth-client`
2. Never call backend directly
3. Handle `onSuccess` and `onError` callbacks
4. Cache is automatically invalidated

### When Debugging Auth Issues

1. Check server logs for "session ‚Üí" output
2. Check if proxy is catching requests at `/api/auth/*`
3. Verify cookies are being set (Network tab)
4. Check cache configuration (`staleTime`)

### When Modifying Auth Config

1. Backend config: `packages/auth/src/config/backend-config.ts`
2. Client config: `apps/web/src/lib/auth/auth-client.ts`
3. Server instance: `apps/web/src/lib/auth/auth-server.ts`
4. Always update documentation after changes

---

## üìö Full Documentation

For complete details, see:

- [Authentication Overview](./apps/fumadocs/content/docs/authentication/overview.mdx) - Complete architecture
- [Quick Reference](./apps/fumadocs/content/docs/authentication/quick-reference.mdx) - Quick reference
- [Implementation Details](./apps/fumadocs/content/docs/authentication/implementation.mdx) - Implementation summary
- [Main Authentication Docs](./apps/fumadocs/content/docs/authentication.mdx) - User-facing documentation

Or visit the live documentation site at `/docs/authentication` when running fumadocs.

---

## üéì Key Learnings for AI

1. **TanStack Start IS Full-Stack**: With this pattern, it competes with Next.js App Router
2. **Proxy Pattern is Critical**: Solves cross-origin cookie issues elegantly
3. **Server Validation is Security**: Client-side checks can be bypassed
4. **Context Flow is Powerful**: No prop drilling, type-safe data flow
5. **Caching is Performance**: Multi-layer caching = 90% query reduction

---

Last Updated: 2026-02-01
