---
title: Promise Handlers
description: Convenience wrappers for promise-based operations
---

# Promise Handlers

## Overview

Promise handler utilities provide convenient wrappers for common promise patterns with automatic error handling using the Result type pattern.

## Why Use Promise Handlers?

1. **Less Boilerplate**: Reduces repetitive try/catch and error handling code
2. **Consistent Error Handling**: All promises are handled the same way
3. **Type Safety**: TypeScript ensures proper error handling
4. **Composable**: Can be chained and combined with other Result operations

## Handler Functions

### `handleDatabaseQuery<T>(queryPromise: Promise<T[]>, notFoundMessage?: string): Promise<T>`

Executes a database query and handles the result automatically. Expects a single item.

```typescript
import { handleDatabaseQuery } from "../utils/promise-handlers";

const user = await handleDatabaseQuery(
  db.select().from(users).where(eq(users.id, userId)).limit(1),
  "User not found"
);
```

### `handleDatabaseListQuery<T>(queryPromise: Promise<T[]>): Promise<T[]>`

Executes a database list query and handles the result automatically. Returns empty array if no results.

```typescript
const users = await handleDatabaseListQuery(
  db.select().from(users).where(eq(users.status, "active"))
);
```

### `handleDatabaseMutation<T>(mutationPromise: Promise<T[]>, notFoundMessage?: string): Promise<T>`

Executes a database mutation and handles the result automatically.

```typescript
const updated = await handleDatabaseMutation(
  db.update(users)
    .set({ name: "John" })
    .where(eq(users.id, userId))
    .returning(),
  "User not found"
);
```

### `handleValidationPromise<T>(promise: Promise<T>, validationErrorClass?: new (...args: any[]) => Error): Promise<T>`

Executes a promise with validation error handling. Converts validation errors to `BadRequestError`.

```typescript
const validated = await handleValidationPromise(
  validateUserInput(input),
  ValidationError
);
```

### `handleParallelPromises<T>(promises: Promise<T>[]): Promise<T[]>`

Executes multiple promises in parallel and handles all results.

```typescript
const [user, profile] = await handleParallelPromises([
  db.select().from(users).where(eq(users.id, userId)),
  db.select().from(profiles).where(eq(profiles.userId, userId)),
]);
```

## Usage Examples

### Single Item Query

```typescript
.get("/:id", async ({ params }) => {
  const user = await handleDatabaseQuery(
    db.select()
      .from(users)
      .where(eq(users.id, params.id))
      .limit(1),
    "User not found"
  );

  return successBody(user);
})
```

### List Query

```typescript
.get("/", async () => {
  const users = await handleDatabaseListQuery(
    db.select().from(users).where(eq(users.status, "active"))
  );

  return successBody(users);
})
```

### Update Mutation

```typescript
.put("/:id", async ({ params, body }) => {
  const updated = await handleDatabaseMutation(
    db.update(users)
      .set(body)
      .where(eq(users.id, params.id))
      .returning(),
    "User not found"
  );

  return successBody(updated);
})
```

### Validation

```typescript
.post("/", async ({ body }) => {
  const validated = await handleValidationPromise(
    validateUserInput(body),
    ValidationError
  );

  const [created] = await db.insert(users).values(validated).returning();
  return status(201, createdBody(created));
})
```

### Parallel Operations

```typescript
.get("/:id/full", async ({ params }) => {
  const [user, profile, settings] = await handleParallelPromises([
    db.select().from(users).where(eq(users.id, params.id)),
    db.select().from(profiles).where(eq(profiles.userId, params.id)),
    db.select().from(settings).where(eq(settings.userId, params.id)),
  ]);

  return successBody({ user, profile, settings });
})
```

## Comparison with Error Handlers

**Promise Handlers** (this module):

- Direct promise execution
- Less verbose
- Good for simple operations

**Error Handlers**:

- Work with Result types
- More explicit error handling
- Better for complex error mapping

Choose based on your preference and use case.

## Best Practices

1. **Use appropriate handler**: Match the handler to your operation type
2. **Provide error messages**: Customize `notFoundMessage` for better UX
3. **Handle validation separately**: Use `handleValidationPromise` for validation
4. **Parallel operations**: Use `handleParallelPromises` for independent operations

## See Also

- [Error Handlers](/docs/backend/error-handlers) - Result-based error handling
- [Result Types](/docs/backend/result-types) - Understanding Result pattern
- [Response Helpers](/docs/backend/response-helpers) - Creating responses
