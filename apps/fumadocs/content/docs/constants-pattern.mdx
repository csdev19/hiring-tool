---
title: Constants Pattern
description: Documentation for the type-safe constants pattern used in the project
tags:
  - patterns
  - typescript
  - constants
  - best-practices
---

# Constants Pattern

**Last Updated:** December 22, 2025  
**Status:** Active Pattern

## Overview

This document describes the **type-safe constants pattern** used throughout the project. This pattern provides type safety, autocompletion, and runtime validation for enum-like values.

## Pattern Structure

The pattern consists of four main parts:

1. **Constant Object** - Defines the values as a const object
2. **Type Definition** - Extracts the type from the constant object
3. **Values Array** - Array of all valid values for runtime checks
4. **Validation Function** - Type guard to validate values at runtime

## Example Implementation

```typescript
import type { ObjectProperties } from "../types";

// 1. Constant object with all possible values
export const CURRENCIES = {
  USD: "USD",
  PEN: "PEN",
} as const;

// 2. Type extracted from the constant object
export type Currency = ObjectProperties<typeof CURRENCIES>;

// 3. Array of all valid values
export const CURRENCY_VALUES = [CURRENCIES.USD, CURRENCIES.PEN] as const;

// 4. Type guard for runtime validation
export function isValidCurrency(value: string): value is Currency {
  return CURRENCY_VALUES.includes(value as Currency);
}
```

## Benefits

### 1. Type Safety

- TypeScript knows all possible values at compile time
- Prevents typos and invalid values
- Full autocompletion support

### 2. Single Source of Truth

- Values are defined once in the constant object
- Changes propagate automatically through types
- No need to update multiple places

### 3. Runtime Validation

- Type guard functions allow runtime checks
- Useful for API validation, form validation, etc.
- Type narrowing works correctly

### 4. Refactoring Safety

- Renaming values is safe (TypeScript will catch all usages)
- Adding/removing values is straightforward
- IDE can find all usages easily

## Usage Examples

### In Type Definitions

```typescript
// ✅ Good: Using the type from constants
import type { Currency } from "@interviews-tool/domain/constants";

interface Interview {
  currency: Currency; // Type-safe, only USD or PEN allowed
}
```

### In Components

```typescript
// ✅ Good: Using constants instead of string literals
import { CURRENCIES, CURRENCY_INFO } from "@interviews-tool/domain/constants";

const currencyOptions = [
  { value: CURRENCIES.USD, label: CURRENCY_INFO[CURRENCIES.USD].label },
  { value: CURRENCIES.PEN, label: CURRENCY_INFO[CURRENCIES.PEN].label },
];
```

### In Validation

```typescript
// ✅ Good: Using type guard for validation
import { isValidCurrency } from "@interviews-tool/domain/constants";

function validateCurrency(input: string): Currency | null {
  if (isValidCurrency(input)) {
    return input; // TypeScript knows this is Currency
  }
  return null;
}
```

### In Backend Validation

```typescript
// ✅ Good: Using constants in Elysia validation
import { CURRENCIES } from "@interviews-tool/domain/constants";
import { t } from "elysia";

body: t.Object({
  currency: t.Optional(
    t.Union([
      t.Literal(CURRENCIES.USD),
      t.Literal(CURRENCIES.PEN),
    ]),
  ),
})
```

## When to Use This Pattern

### ✅ Use This Pattern For:

- Enum-like values that won't change frequently
- Values that need type safety
- Values used across multiple files/packages
- Values that need runtime validation
- Database enums or status fields

### ❌ Don't Use This Pattern For:

- Simple one-off constants
- Values that change very frequently
- Values only used in a single file
- Configuration values that come from environment

## File Organization

Constants should be placed in:

```
packages/domain/src/constants/
  ├── currency.ts
  ├── interview-status.ts
  └── ...
```

Each constant file should:

- Export the constant object
- Export the type
- Export the values array
- Export the validation function
- Include JSDoc comments

## Adding New Values

When adding a new value to an existing constant:

1. Add the value to the constant object
2. Add it to the values array
3. TypeScript will automatically update the type
4. Update any switch statements or mappings
5. Update validation schemas if needed

### Example: Adding EUR Currency

```typescript
// Before
export const CURRENCIES = {
  USD: "USD",
  PEN: "PEN",
} as const;

// After
export const CURRENCIES = {
  USD: "USD",
  PEN: "PEN",
  EUR: "EUR", // New value
} as const;

// Update values array
export const CURRENCY_VALUES = [
  CURRENCIES.USD,
  CURRENCIES.PEN,
  CURRENCIES.EUR, // Add here
] as const;

// Update info object if it exists
export const CURRENCY_INFO: Record<Currency, { label: string; symbol: string }> = {
  USD: { label: "US Dollar", symbol: "$" },
  PEN: { label: "Peruvian Sol", symbol: "S/" },
  EUR: { label: "Euro", symbol: "€" }, // Add here
};
```

## Type Utility: ObjectProperties

The `ObjectProperties` utility type extracts all property values from a const object:

```typescript
export type ObjectProperties<T> = T[keyof T];

// Example
const STATUSES = {
  ACTIVE: "active",
  INACTIVE: "inactive",
} as const;

type Status = ObjectProperties<typeof STATUSES>;
// Result: "active" | "inactive"
```

This utility is essential for the pattern to work correctly.

## Current Constants in Project

### Currency (`packages/domain/src/constants/currency.ts`)

- `CURRENCIES` - Currency codes (USD, PEN)
- `Currency` - Type for currency values
- `CURRENCY_VALUES` - Array of all currencies
- `isValidCurrency()` - Validation function
- `CURRENCY_INFO` - Display information (label, symbol)

### Interview Status (`packages/domain/src/constants/interview-status.ts`)

- `INTERVIEW_STATUSES` - Status values (ongoing, rejected, dropped-out, hired)
- `InterviewStatus` - Type for status values
- `INTERVIEW_STATUS_VALUES` - Array of all statuses
- `isValidInterviewStatus()` - Validation function

## Best Practices

1. **Always use constants, never string literals**

   ```typescript
   // ❌ Bad
   status: "ongoing"

   // ✅ Good
   status: INTERVIEW_STATUSES.ONGOING
   ```

2. **Use the type, not the union**

   ```typescript
   // ❌ Bad
   type Status = "ongoing" | "rejected";

   // ✅ Good
   import type { InterviewStatus } from "@interviews-tool/db";
   ```

3. **Use validation functions for runtime checks**

   ```typescript
   // ❌ Bad
   if (value === "USD" || value === "PEN") { ... }

   // ✅ Good
   if (isValidCurrency(value)) { ... }
   ```

4. **Export from domain package**

   ```typescript
   // ✅ Good: Export from @interviews-tool/domain/constants
   export * from "./constants/currency";
   ```

5. **Add JSDoc comments**
   ```typescript
   /**
    * Type for currency values
    */
   export type Currency = ObjectProperties<typeof CURRENCIES>;
   ```

## Migration Guide

When migrating existing string literal types to this pattern:

1. Create the constant file following the pattern
2. Update type imports to use the new type
3. Replace string literals with constant references
4. Update validation schemas
5. Test thoroughly

## References

- [TypeScript Const Assertions](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions)
- [TypeScript Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)
- [Type Guards](https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates)

---

**Pattern Status:** ✅ Recommended for all enum-like values  
**Maintained By:** Development Team
