---
title: Application Services Layer
description: Complete guide to implementing the Application layer with Use Cases, Commands, Queries, and DTOs
---

# Application Services Layer

The **Application Layer** (also called Application Services or Use Cases layer) orchestrates domain logic to fulfill specific user actions. It sits between the presentation layer (HTTP/UI) and the domain layer.

---

## ğŸ¯ Purpose of Application Layer

The Application Layer:

- âœ… **Orchestrates** domain objects to complete a task
- âœ… **Validates** input from external sources
- âœ… **Manages** transactions and persistence
- âœ… **Publishes** domain events
- âœ… **Transforms** domain models to DTOs

It does **NOT**:

- âŒ Contain business rules (those go in domain)
- âŒ Access database directly (uses repositories)
- âŒ Handle HTTP concerns (that's infrastructure)

---

## ğŸ“¦ Application Layer Structure

```bash
packages/hiring/application/
â”œâ”€â”€ use-cases/                    # Commands (writes)
â”‚   â”œâ”€â”€ create-hiring-process/
â”‚   â”‚   â”œâ”€â”€ create-hiring-process.command.ts
â”‚   â”‚   â”œâ”€â”€ create-hiring-process.handler.ts
â”‚   â”‚   â”œâ”€â”€ create-hiring-process.validator.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ update-status/
â”‚   â”‚   â”œâ”€â”€ update-status.command.ts
â”‚   â”‚   â”œâ”€â”€ update-status.handler.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ add-interaction/
â”‚   â””â”€â”€ delete-hiring-process/
â”‚
â”œâ”€â”€ queries/                      # Queries (reads)
â”‚   â”œâ”€â”€ get-hiring-process/
â”‚   â”‚   â”œâ”€â”€ get-hiring-process.query.ts
â”‚   â”‚   â”œâ”€â”€ get-hiring-process.handler.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â”œâ”€â”€ list-hiring-processes/
â”‚   â”‚   â”œâ”€â”€ list-hiring-processes.query.ts
â”‚   â”‚   â”œâ”€â”€ list-hiring-processes.handler.ts
â”‚   â”‚   â””â”€â”€ index.ts
â”‚   â””â”€â”€ get-hiring-stats/
â”‚
â”œâ”€â”€ dto/                          # Data Transfer Objects
â”‚   â”œâ”€â”€ hiring-process.dto.ts
â”‚   â”œâ”€â”€ create-hiring-process.dto.ts
â”‚   â”œâ”€â”€ update-hiring-process.dto.ts
â”‚   â””â”€â”€ index.ts
â”‚
â”œâ”€â”€ services/                     # Application services (if needed)
â”‚   â””â”€â”€ hiring-process.service.ts
â”‚
â”œâ”€â”€ events/                       # Application event handlers
â”‚   â””â”€â”€ hiring-process-created.handler.ts
â”‚
â””â”€â”€ index.ts                      # Barrel exports
```

---

## ğŸ”€ CQRS Pattern (Commands and Queries)

We use **CQRS** (Command Query Responsibility Segregation) to separate writes from reads:

### Commands (Write Operations)

**Change system state, no return value (or just ID)**

```typescript
// packages/hiring/application/use-cases/create-hiring-process/create-hiring-process.command.ts

/**
 * Command to create a new hiring process
 *
 * Commands represent user intentions to change system state
 */
export class CreateHiringProcessCommand {
  constructor(
    public readonly userId: string,
    public readonly companyName: string,
    public readonly position: string,
    public readonly salary?: number,
    public readonly currency?: string,
    public readonly salaryRateType?: string,
  ) {}
}
```

**Command Handler:**

```typescript
// packages/hiring/application/use-cases/create-hiring-process/create-hiring-process.handler.ts

import type { IHiringProcessRepository } from "@hiring-tool/hiring/domain/repositories";
import type { IEventPublisher } from "@hiring-tool/shared-kernel/events";
import { HiringProcess } from "@hiring-tool/hiring/domain/entities";
import { Salary } from "@hiring-tool/hiring/domain/value-objects";
import type { CreateHiringProcessCommand } from "./create-hiring-process.command";
import { Result, tryCatch } from "@hiring-tool/shared-kernel/result";

export class CreateHiringProcessHandler {
  constructor(
    private readonly hiringProcessRepo: IHiringProcessRepository,
    private readonly eventPublisher: IEventPublisher,
  ) {}

  async execute(command: CreateHiringProcessCommand): Promise<Result<string, Error>> {
    // 1. Validate business rules (if not in domain)
    // Already validated by Zod at API boundary

    // 2. Create domain entity with business logic
    const salary = command.salary
      ? Salary.create({
          amount: command.salary,
          currency: command.currency || "USD",
          rateType: command.salaryRateType || "monthly",
        })
      : null;

    const hiringProcess = HiringProcess.create({
      userId: command.userId,
      companyName: command.companyName,
      position: command.position,
      salary,
    });

    // 3. Persist using repository
    const saveResult = await tryCatch(
      this.hiringProcessRepo.save(hiringProcess)
    );

    if (saveResult.error) {
      return saveResult;
    }

    // 4. Publish domain events
    const events = hiringProcess.getDomainEvents();
    await this.eventPublisher.publishAll(events);

    // 5. Return success with ID
    return { data: hiringProcess.id, error: null };
  }
}
```

---

### Queries (Read Operations)

**Read system state, no side effects**

```typescript
// packages/hiring/application/queries/get-hiring-process/get-hiring-process.query.ts

/**
 * Query to get a single hiring process
 *
 * Queries fetch data without changing system state
 */
export class GetHiringProcessQuery {
  constructor(
    public readonly hiringProcessId: string,
    public readonly userId: string,
  ) {}
}
```

**Query Handler:**

```typescript
// packages/hiring/application/queries/get-hiring-process/get-hiring-process.handler.ts

import type { IHiringProcessRepository } from "@hiring-tool/hiring/domain/repositories";
import type { GetHiringProcessQuery } from "./get-hiring-process.query";
import type { HiringProcessDTO } from "../../dto/hiring-process.dto";
import { HiringProcessMapper } from "../../mappers/hiring-process-dto.mapper";
import { Result } from "@hiring-tool/shared-kernel/result";

export class GetHiringProcessHandler {
  constructor(
    private readonly hiringProcessRepo: IHiringProcessRepository,
  ) {}

  async execute(query: GetHiringProcessQuery): Promise<Result<HiringProcessDTO, Error>> {
    // 1. Fetch from repository
    const hiringProcess = await this.hiringProcessRepo.findById(
      query.hiringProcessId,
      query.userId,
    );

    if (!hiringProcess) {
      return {
        data: null,
        error: new Error("Hiring process not found"),
      };
    }

    // 2. Transform domain entity to DTO
    const dto = HiringProcessMapper.toDTO(hiringProcess);

    // 3. Return DTO
    return { data: dto, error: null };
  }
}
```

---

## ğŸ“‹ Data Transfer Objects (DTOs)

DTOs are simple data containers for transferring data between layers:

```typescript
// packages/hiring/application/dto/hiring-process.dto.ts

import type { Currency, SalaryRateType } from "@hiring-tool/shared-kernel";
import type { HiringProcessStatus } from "@hiring-tool/hiring/domain";

/**
 * DTO for hiring process representation
 *
 * DTOs are:
 * - Plain objects (no methods)
 * - Framework-agnostic
 * - Easy to serialize/deserialize
 * - Different from domain entities
 */
export interface HiringProcessDTO {
  id: string;
  userId: string;
  companyName: string;
  position: string;
  status: HiringProcessStatus;
  salary: number | null;
  currency: Currency;
  salaryRateType: SalaryRateType;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * DTO for creating a hiring process
 */
export interface CreateHiringProcessDTO {
  companyName: string;
  position: string;
  salary?: number;
  currency?: Currency;
  salaryRateType?: SalaryRateType;
}

/**
 * DTO for updating a hiring process
 */
export interface UpdateHiringProcessDTO {
  companyName?: string;
  position?: string;
  status?: HiringProcessStatus;
  salary?: number;
  currency?: Currency;
  salaryRateType?: SalaryRateType;
}

/**
 * DTO for hiring process list item (simplified)
 */
export interface HiringProcessListItemDTO {
  id: string;
  companyName: string;
  position: string;
  status: HiringProcessStatus;
  createdAt: Date;
}
```

---

## ğŸ—ºï¸ DTO Mappers

Mappers convert between domain entities and DTOs:

```typescript
// packages/hiring/application/mappers/hiring-process-dto.mapper.ts

import type { HiringProcess } from "@hiring-tool/hiring/domain/entities";
import type {
  HiringProcessDTO,
  HiringProcessListItemDTO,
} from "../dto/hiring-process.dto";

export class HiringProcessDTOMapper {
  /**
   * Convert domain entity to full DTO
   */
  static toDTO(entity: HiringProcess): HiringProcessDTO {
    return {
      id: entity.id,
      userId: entity.userId,
      companyName: entity.companyName,
      position: entity.position,
      status: entity.status.value,
      salary: entity.salary?.amount ?? null,
      currency: entity.salary?.currency ?? "USD",
      salaryRateType: entity.salary?.rateType ?? "monthly",
      createdAt: entity.createdAt,
      updatedAt: entity.updatedAt,
    };
  }

  /**
   * Convert domain entity to list item DTO (simplified)
   */
  static toListItemDTO(entity: HiringProcess): HiringProcessListItemDTO {
    return {
      id: entity.id,
      companyName: entity.companyName,
      position: entity.position,
      status: entity.status.value,
      createdAt: entity.createdAt,
    };
  }

  /**
   * Convert array of entities to list DTOs
   */
  static toListDTOs(entities: HiringProcess[]): HiringProcessListItemDTO[] {
    return entities.map(entity => this.toListItemDTO(entity));
  }
}
```

---

## ğŸ—ï¸ Application Service (Alternative Pattern)

Instead of separate Commands/Queries, you can use an Application Service class:

```typescript
// packages/hiring/application/services/hiring-process.service.ts

import type { IHiringProcessRepository } from "@hiring-tool/hiring/domain/repositories";
import type { IEventPublisher } from "@hiring-tool/shared-kernel/events";
import { HiringProcess } from "@hiring-tool/hiring/domain/entities";
import type {
  CreateHiringProcessDTO,
  UpdateHiringProcessDTO,
  HiringProcessDTO,
} from "../dto";
import { HiringProcessDTOMapper } from "../mappers/hiring-process-dto.mapper";
import { Result, tryCatch } from "@hiring-tool/shared-kernel/result";

export class HiringProcessService {
  constructor(
    private readonly hiringProcessRepo: IHiringProcessRepository,
    private readonly eventPublisher: IEventPublisher,
  ) {}

  async create(
    userId: string,
    dto: CreateHiringProcessDTO,
  ): Promise<Result<string, Error>> {
    // Create domain entity
    const hiringProcess = HiringProcess.create({
      userId,
      ...dto,
    });

    // Save
    const result = await tryCatch(
      this.hiringProcessRepo.save(hiringProcess)
    );

    if (result.error) {
      return result;
    }

    // Publish events
    await this.eventPublisher.publishAll(hiringProcess.getDomainEvents());

    return { data: hiringProcess.id, error: null };
  }

  async update(
    id: string,
    userId: string,
    dto: UpdateHiringProcessDTO,
  ): Promise<Result<HiringProcessDTO, Error>> {
    // Fetch entity
    const hiringProcess = await this.hiringProcessRepo.findById(id, userId);

    if (!hiringProcess) {
      return {
        data: null,
        error: new Error("Hiring process not found"),
      };
    }

    // Update entity (business logic in domain)
    if (dto.companyName) {
      hiringProcess.updateCompanyName(dto.companyName);
    }

    if (dto.status) {
      hiringProcess.updateStatus(dto.status);
    }

    // Save
    const result = await tryCatch(
      this.hiringProcessRepo.update(hiringProcess)
    );

    if (result.error) {
      return { data: null, error: result.error };
    }

    // Return DTO
    return {
      data: HiringProcessDTOMapper.toDTO(hiringProcess),
      error: null,
    };
  }

  async getById(
    id: string,
    userId: string,
  ): Promise<Result<HiringProcessDTO, Error>> {
    const hiringProcess = await this.hiringProcessRepo.findById(id, userId);

    if (!hiringProcess) {
      return {
        data: null,
        error: new Error("Hiring process not found"),
      };
    }

    return {
      data: HiringProcessDTOMapper.toDTO(hiringProcess),
      error: null,
    };
  }

  async list(userId: string): Promise<Result<HiringProcessDTO[], Error>> {
    const result = await tryCatch(
      this.hiringProcessRepo.findByUserId(userId)
    );

    if (result.error) {
      return { data: null, error: result.error };
    }

    return {
      data: result.data.map(HiringProcessDTOMapper.toDTO),
      error: null,
    };
  }
}
```

---

## ğŸ”Œ Wiring in Infrastructure (HTTP Layer)

The application layer is called from HTTP routes:

```typescript
// apps/server/src/routes/hiring-processes.ts

import { Elysia } from "elysia";
import { CreateHiringProcessHandler } from "@hiring-tool/hiring/application";
import { CreateHiringProcessCommand } from "@hiring-tool/hiring/application";
import { HiringProcessRepositoryDrizzle } from "@hiring-tool/hiring/infrastructure";

export const hiringProcessRoutes = new Elysia({ prefix: "/hiring-processes" })
  .derive(({ db }) => ({
    // Dependency injection
    hiringProcessRepo: new HiringProcessRepositoryDrizzle(db),
    createHiringProcessHandler: new CreateHiringProcessHandler(
      new HiringProcessRepositoryDrizzle(db),
      eventPublisher,
    ),
  }))
  .post(
    "/",
    async ({ body, user, createHiringProcessHandler, status }) => {
      // Create command from HTTP body
      const command = new CreateHiringProcessCommand(
        user.id,
        body.companyName,
        body.position,
        body.salary,
        body.currency,
        body.salaryRateType,
      );

      // Execute use case
      const result = await createHiringProcessHandler.execute(command);

      // Handle result
      if (result.error) {
        return status(400, {
          data: null,
          error: { message: result.error.message },
        });
      }

      return status(201, {
        data: { id: result.data },
        error: null,
      });
    },
    {
      body: createHiringProcessSchema,
      isAuth: true,
    },
  );
```

---

## ğŸ§ª Testing Application Layer

Application layer is easy to test with mocks:

```typescript
// packages/hiring/application/use-cases/create-hiring-process/__tests__/create-hiring-process.handler.test.ts

import { describe, it, expect, beforeEach, vi } from "vitest";
import { CreateHiringProcessHandler } from "../create-hiring-process.handler";
import { CreateHiringProcessCommand } from "../create-hiring-process.command";
import type { IHiringProcessRepository } from "@hiring-tool/hiring/domain/repositories";
import type { IEventPublisher } from "@hiring-tool/shared-kernel/events";

describe("CreateHiringProcessHandler", () => {
  let handler: CreateHiringProcessHandler;
  let mockRepo: IHiringProcessRepository;
  let mockEventPublisher: IEventPublisher;

  beforeEach(() => {
    // Mock repository
    mockRepo = {
      save: vi.fn().mockResolvedValue(undefined),
      findById: vi.fn(),
    };

    // Mock event publisher
    mockEventPublisher = {
      publishAll: vi.fn().mockResolvedValue(undefined),
    };

    handler = new CreateHiringProcessHandler(mockRepo, mockEventPublisher);
  });

  it("should create hiring process successfully", async () => {
    // Arrange
    const command = new CreateHiringProcessCommand(
      "user-123",
      "ACME Corp",
      "Senior Developer",
      100000,
      "USD",
      "monthly",
    );

    // Act
    const result = await handler.execute(command);

    // Assert
    expect(result.error).toBeNull();
    expect(result.data).toBeDefined();
    expect(mockRepo.save).toHaveBeenCalledOnce();
    expect(mockEventPublisher.publishAll).toHaveBeenCalledOnce();
  });

  it("should return error when repository fails", async () => {
    // Arrange
    mockRepo.save = vi.fn().mockRejectedValue(new Error("DB Error"));
    const command = new CreateHiringProcessCommand(
      "user-123",
      "ACME Corp",
      "Senior Developer",
    );

    // Act
    const result = await handler.execute(command);

    // Assert
    expect(result.error).toBeDefined();
    expect(result.data).toBeNull();
  });
});
```

---

## ğŸ“ Application Layer Patterns

### Pattern 1: Command/Query Handlers (Recommended)

**Structure:**

```
use-cases/create-hiring-process/
  - command.ts      â† Command definition
  - handler.ts      â† Command handler
  - validator.ts    â† Optional validation
```

**Benefits:**

- âœ… Single Responsibility
- âœ… Easy to test
- âœ… Clear separation
- âœ… Scalable

---

### Pattern 2: Application Service Class

**Structure:**

```
services/
  - hiring-process.service.ts  â† All operations in one class
```

**Benefits:**

- âœ… Grouped related operations
- âœ… Less boilerplate
- âœ… Familiar pattern

**Drawbacks:**

- âš ï¸ Can become large (God class)
- âš ï¸ Mixed responsibilities

---

### Pattern 3: Feature Folders (Vertical Slices)

**Structure:**

```
features/create-hiring-process/
  - command.ts
  - handler.ts
  - validator.ts
  - dto.ts
  - route.ts
```

**Benefits:**

- âœ… Everything related to feature in one place
- âœ… Easy to find code
- âœ… Can be moved to separate package

---

## ğŸ¯ Best Practices

### 1. Keep Application Layer Thin

```typescript
// âŒ Bad - Business logic in application layer
async create(dto: CreateDTO) {
  if (dto.salary < 0) {  // Business rule!
    throw new Error("Salary must be positive");
  }
  // ...
}

// âœ… Good - Business logic in domain
async create(dto: CreateDTO) {
  const process = HiringProcess.create(dto);  // Validation in entity
  await this.repo.save(process);
}
```

---

### 2. Use DTOs for External Communication

```typescript
// âœ… Good - Return DTO, not domain entity
async getById(id: string): Promise<HiringProcessDTO> {
  const entity = await this.repo.findById(id);
  return HiringProcessDTOMapper.toDTO(entity);
}

// âŒ Bad - Exposing domain entity
async getById(id: string): Promise<HiringProcess> {
  return await this.repo.findById(id);  // Domain leaks out!
}
```

---

### 3. Use Result Pattern for Error Handling

```typescript
// âœ… Good - Explicit error handling
async execute(command: Command): Promise<Result<string, Error>> {
  const result = await tryCatch(this.repo.save(entity));
  return result;
}

// âŒ Bad - Throwing exceptions
async execute(command: Command): Promise<string> {
  await this.repo.save(entity);  // Exception can be thrown
  return entity.id;
}
```

---

### 4. Publish Domain Events

```typescript
// âœ… Good - Events published by application layer
async execute(command: Command) {
  const entity = Entity.create(command);
  await this.repo.save(entity);
  await this.eventPublisher.publishAll(entity.getDomainEvents());
}
```

---

## ğŸ”— Related Documentation

- [Bounded Contexts Complete Guide](/docs/architecture/bounded-contexts-complete-guide)
- [Repository Pattern](/docs/architecture/repository-pattern)
- [Domain Entities & Value Objects](/docs/architecture/domain-entities)

---

_Last Updated: {new Date().toISOString().split('T')[0]}_
